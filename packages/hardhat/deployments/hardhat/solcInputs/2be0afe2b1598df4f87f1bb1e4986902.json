{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint128 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint128 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint128 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint128 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint128 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint128 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint128 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint128 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint128 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint128 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint128 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint128 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint128 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint128 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint128 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint128 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint128 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint128 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint128 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint128 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/assetPurchase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IERC20 {\n    function transferFrom(address from, address to, uint128 amount) external returns (bool);\n    function transfer(address recipient, uint128 amount) external returns (bool);\n}\n\ninterface IStableSwapGateway {\n    function lockRedemption(address user) external;\n}\n\ncontract AssetPurchase {\n    address public admin;\n\n    enum Status { Pending, InProgress, Completed, Cancelled }\n\n    struct Asset {\n        string name;\n        uint128 priceInGBDO; // e.g., $100 = 100e6\n        string metadataCID;\n        bool active;\n        uint32 baseDays;\n        uint256 perUnitDelay;\n    }\n\n    struct Purchase {\n        address buyer;\n        address tokenUsed;\n        uint64 assetId;\n        uint32 quantity;\n        uint256 depositAmount;\n        uint256 escrowAmount;\n        uint256 purchaseTime;\n        uint256 deliveryDeadline;\n        string progressCID;\n        string completionCID;\n        Status status;\n        uint256 proposedExtension;\n        bool extensionPending;\n    }\n\n    address public feeRecipient;\n    uint256 public constant FEE_BASIS_POINTS = 5; // 0.005% = 5 / 1,000,000\n    uint256 public constant BASIS_POINT_DIVISOR = 1_000_000;\n\n    uint256 public nextAssetId;\n    uint256 public nextPurchaseId;\n\n    mapping(uint256 => Asset) public assets;\n    mapping(uint256 => Purchase) public purchases;\n    mapping(address => uint256) public stableTokenToRate; // token → micro USD\n\n    IStableSwapGateway public redemptionGateway;\n\n    event AssetAdded(uint256 id, string name);\n    event Purchased(uint256 indexed purchaseId, address indexed buyer, uint64 assetId);\n    event ProgressUploaded(uint256 id, string cid);\n    event CompletionUploaded(uint256 id, string cid);\n    event EscrowReleased(uint256 id);\n    event Refunded(uint256 id);\n    event ExtensionProposed(uint256 id, uint256 duration);\n    event ExtensionApproved(uint256 id, uint256 newDeadline);\n    event RedemptionLocked(address user);\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Not admin\");\n        _;\n    }\n\n    constructor() {\n        admin = msg.sender;\n        feeRecipient = msg.sender; // or a treasury/multisig wallet\n\n    }\n\n    function setRate(address token, uint256 rate) external onlyAdmin {\n        stableTokenToRate[token] = rate;\n    }\n\n    function setRedemptionGateway(address gateway) external onlyAdmin {\n        require(gateway != address(0), \"Invalid gateway\");\n        redemptionGateway = IStableSwapGateway(gateway);\n    }\n\n    function addAsset(\n        string calldata name,\n        uint256 usdPrice,\n        string calldata cid,\n        uint32 baseDays,\n        uint32 delayPerUnit\n    ) external onlyAdmin {\n        assets[nextAssetId] = Asset(name, usdPrice, cid, true, baseDays, delayPerUnit);\n        emit AssetAdded(nextAssetId, name);\n        nextAssetId++;\n    }\n\n    function purchase(uint64 assetId, uint32 quantity, address token) external {\n        Asset memory a = assets[assetId];\n        require(a.active, \"Asset inactive\");\n        require(quantity > 0, \"Invalid quantity\");\n\n        uint256 rate = stableTokenToRate[token];\n        require(rate > 0, \"Rate not set\");\n\n        uint256 totalGBDO = a.priceInGBDO * quantity;\n        uint256 totalToken = (totalGBDO * 1e18) / rate;\n        uint256 deposit = totalToken / 2;\n        uint256 escrow = totalToken - deposit;\n\n        uint256 feeAmount = (totalToken * FEE_BASIS_POINTS) / BASIS_POINT_DIVISOR;\n        uint256 netAmount = totalToken - feeAmount;\n\n\n        IERC20(token).transferFrom(msg.sender, address(this), netAmount);\n        IERC20(token).transferFrom(msg.sender, feeRecipient, feeAmount);\n\n\n        uint256 delay = a.baseDays + a.perUnitDelay * (quantity - 1);\n        uint256 deadline = block.timestamp + delay * 1 days;\n\n        purchases[nextPurchaseId] = Purchase(\n            msg.sender,\n            token,\n            assetId,\n            quantity,\n            deposit,\n            escrow,\n            block.timestamp,\n            deadline,\n            \"\",\n            \"\",\n            Status.InProgress,\n            0,\n            false\n        );\n\n        emit Purchased(nextPurchaseId, msg.sender, assetId);\n\n        if (address(redemptionGateway) != address(0)) {\n            redemptionGateway.lockRedemption(msg.sender);\n            emit RedemptionLocked(msg.sender);\n        }\n\n        nextPurchaseId++;\n    }\n\n    function uploadProgress(uint256 id, string calldata cid) external onlyAdmin {\n        Purchase storage p = purchases[id];\n        require(p.status == Status.InProgress, \"Not active\");\n        p.progressCID = cid;\n        emit ProgressUploaded(id, cid);\n    }\n\n    function uploadCompletion(uint256 id, string calldata cid) external onlyAdmin {\n        Purchase storage p = purchases[id];\n        require(p.status == Status.InProgress, \"Not active\");\n        p.completionCID = cid;\n        emit CompletionUploaded(id, cid);\n    }\n\n    function releaseEscrow(uint256 id) external onlyAdmin {\n        Purchase storage p = purchases[id];\n        require(p.status == Status.InProgress, \"Not active\");\n        require(bytes(p.completionCID).length > 0, \"No final proof\");\n\n        p.status = Status.Completed;\n        IERC20(p.tokenUsed).transfer(admin, p.escrowAmount);\n        emit EscrowReleased(id);\n    }\n\n    function autoRefund(uint256 id) external {\n        Purchase storage p = purchases[id];\n        require(p.status == Status.InProgress, \"Not active\");\n        require(block.timestamp > p.deliveryDeadline, \"Not expired\");\n        require(bytes(p.completionCID).length == 0, \"Already fulfilled\");\n\n        p.status = Status.Cancelled;\n        IERC20(p.tokenUsed).transfer(p.buyer, p.escrowAmount);\n        emit Refunded(id);\n    }\n\n    function proposeExtension(uint256 id, uint256 extraDays) external onlyAdmin {\n        Purchase storage p = purchases[id];\n        require(p.status == Status.InProgress, \"Not active\");\n        require(!p.extensionPending, \"Already proposed\");\n\n        p.proposedExtension = extraDays;\n        p.extensionPending = true;\n        emit ExtensionProposed(id, extraDays);\n    }\n\n    function approveExtension(uint256 id) external {\n        Purchase storage p = purchases[id];\n        require(msg.sender == p.buyer, \"Not buyer\");\n        require(p.extensionPending, \"No proposal\");\n\n        p.deliveryDeadline += p.proposedExtension * 1 days;\n        p.extensionPending = false;\n        p.proposedExtension = 0;\n\n        emit ExtensionApproved(id, p.deliveryDeadline);\n    }\n\n    function cancelPurchase(uint256 id) external {\n        Purchase storage p = purchases[id];\n        require(msg.sender == p.buyer, \"Not buyer\");\n        require(p.status == Status.InProgress, \"Invalid status\");\n        require(block.timestamp < p.purchaseTime + 5 days, \"Window expired\");\n\n        p.status = Status.Cancelled;\n        uint256 totalRefund = p.depositAmount + p.escrowAmount;\n        IERC20(p.tokenUsed).transfer(p.buyer, totalRefund);\n        emit Refunded(id);\n    }\n\n    function getUserPurchases(address user) external view returns (Purchase[] memory) {\n        uint256 count;\n\n        for (uint256 i = 0; i < nextPurchaseId; i++) {\n            if (purchases[i].buyer == user) count++;\n        }\n\n        Purchase[] memory userTxs = new Purchase[](count);\n        uint256 index;\n\n        for (uint256 i = 0; i < nextPurchaseId; i++) {\n            if (purchases[i].buyer == user) {\n                userTxs[index++] = purchases[i];\n            }\n        }\n\n        return userTxs;\n    }\n\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address account) external view returns (uint);\n    function transfer(address recipient, uint amount) external returns (bool);\n    function approve(address spender, uint amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint);\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n}\n"
    },
    "contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Pair {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n"
    },
    "contracts/smartVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract SmartVault is Ownable {\n    IERC20 public immutable stableToken; // WGBD\n    address public seedNode;\n\n    uint256 public totalDeposits;\n    uint256 public totalProfits;\n    uint256 public currentDistributionId;\n\n    uint256 public investmentReserve;\n    uint256 public productReserve;\n    uint256 public redemptionReserve;\n\n    struct UserInfo {\n        uint128 amount;\n        uint64 depositTime;\n        uint256 claimedDistribution;\n        uint256 recommitCount;\n        uint32 unlockQuarter;\n        uint32 committedQuarters;\n        uint32 unlockQuarter;\n    }\n\n    struct Redemption {\n        address user;\n        uint128 amount;\n        uint256 requestQuarter;\n        bool fulfilled;\n    }\n\n    Redemption[] public redemptionQueue;\n    mapping(address => uint256[]) public userRedemptionIds;\n    mapping(address => UserInfo) public users;\n    mapping(address => bool) public hasLockedRedemption;\n    mapping(uint256 => uint256) public distributionProfits;\n\n    event Deposited(address indexed user, uint128 amount, uint32 committedQuarters);\n    event Recommitted(address indexed user, uint256 newQuartersCommitted);\n    event ProfitAdded(address indexed from, uint128 amount);\n    event Distributed(uint256 id, uint256 totalProfit);\n    event Claimed(address indexed user, uint256 reward);\n    event Withdrawn(address indexed user, uint128 amount);\n    event CapitalAllocated(uint256 investment, uint256 products, uint256 redemptions);\n    event CapitalSpent(address indexed target, uint128 amount, string purpose);\n\n    modifier onlySeed() {\n        require(msg.sender == seedNode, \"Not authorized\");\n        _;\n    }\n\n    constructor(address initialOwner, address _stableToken, address _seedNode) Ownable(initialOwner) {\n        require(_stableToken != address(0), \"Invalid stable token\");\n        require(_seedNode != address(0), \"Invalid seed node\");\n        stableToken = IERC20(_stableToken);\n        seedNode = _seedNode;\n    }\n\n    function deposit(uint128 amount, uint32 committedQuarters) external {\n        require(amount > 0, \"Zero amount\");\n        require(committedQuarters >= 1, \"Minimum 1 quarter commitment\");\n\n        stableToken.transferFrom(msg.sender, address(this), amount);\n\n        UserInfo storage user = users[msg.sender];\n\n        if (user.amount == 0) {\n            user.depositTime = block.timestamp;\n            user.committedQuarters = committedQuarters;\n            user.eligibleQuarter = computeEligibilityQuarter(block.timestamp, committedQuarters);\n            user.unlockQuarter = getQuarter(block.timestamp) + committedQuarters;\n        }\n\n        user.amount += amount;\n        totalDeposits += amount;\n        hasLockedRedemption[msg.sender] = true;\n\n        emit Deposited(msg.sender, amount, committedQuarters);\n    }\n\n    function recommit(uint32 additionalQuarters) external {\n        UserInfo storage user = users[msg.sender];\n        require(block.timestamp >= user.depositTime + (user.committedQuarters * 90 days), \"Still locked\");\n\n        user.depositTime = block.timestamp;\n        user.recommitCount += 1;\n        user.committedQuarters = additionalQuarters;\n        user.eligibleQuarter = computeEligibilityQuarter(block.timestamp, additionalQuarters);\n        user.unlockQuarter = getQuarter(block.timestamp) + additionalQuarters;\n\n        emit Recommitted(msg.sender, additionalQuarters);\n    }\n\n    function requestRedemption() external {\n        UserInfo storage user = users[msg.sender];\n        require(user.amount > 0, \"Nothing to redeem\");\n        require(getQuarter(block.timestamp) >= user.unlockQuarter, \"Still locked\");\n\n        uint128 amount = user.amount;\n        user.amount = 0;\n        totalDeposits -= amount;\n\n        redemptionQueue.push(Redemption({\n            user: msg.sender,\n            amount: amount,\n            requestQuarter: getQuarter(block.timestamp),\n            fulfilled: false\n        }));\n\n        userRedemptionIds[msg.sender].push(redemptionQueue.length - 1);\n        hasLockedRedemption[msg.sender] = false;\n    }\n\n    function getOutstandingRedemptions() external view returns (Redemption[] memory) {\n        uint256 count;\n        for (uint256 i = 0; i < redemptionQueue.length; i++) {\n            if (!redemptionQueue[i].fulfilled) count++;\n        }\n\n        Redemption[] memory pending = new Redemption[](count);\n        uint256 j;\n        for (uint256 i = 0; i < redemptionQueue.length; i++) {\n            if (!redemptionQueue[i].fulfilled) {\n                pending[j++] = redemptionQueue[i];\n            }\n        }\n\n        return pending;\n    }\n\n\n\n    function addProfit(uint128 amount) external {\n        require(amount > 0, \"Zero profit\");\n        stableToken.transferFrom(msg.sender, address(this), amount);\n        totalProfits += amount;\n\n        emit ProfitAdded(msg.sender, amount);\n    }\n\n    function processRedemptions() public onlySeed {\n        for (uint256 i = 0; i < redemptionQueue.length; i++) {\n            Redemption storage r = redemptionQueue[i];\n            if (!r.fulfilled && stableToken.balanceOf(address(this)) >= r.amount) {\n                r.fulfilled = true;\n                redemptionReserve -= r.amount;\n                stableToken.transfer(r.user, r.amount);\n                emit Withdrawn(r.user, r.amount);\n            }\n        }\n    }\n\n\n    function distribute() external onlySeed {\n        require(totalProfits > 0, \"No profits available\");\n        distributionProfits[++currentDistributionId] = totalProfits;\n        emit Distributed(currentDistributionId, totalProfits);\n        totalProfits = 0;\n    }\n\n    function distributeTo(address userAddr) public onlySeed {\n        UserInfo storage user = users[userAddr];\n        if (user.amount == 0) return;\n        if (getQuarter(block.timestamp) < user.eligibleQuarter) return;\n        if (currentDistributionId <= user.claimedDistribution) return;\n\n        uint256 reward;\n        for (uint256 i = user.claimedDistribution + 1; i <= currentDistributionId; i++) {\n            uint256 profit = distributionProfits[i];\n            uint256 multiplier = getMultiplier(user.depositTime, user.committedQuarters);\n            reward += (user.amount * multiplier * profit) / (totalDeposits * 100);\n        }\n\n        user.claimedDistribution = currentDistributionId;\n        if (reward > 0) {\n            stableToken.transfer(userAddr, reward);\n            emit Claimed(userAddr, reward);\n        }\n    }\n\n    function batchDistribute(address[] calldata userList) external onlySeed {\n        for (uint256 i = 0; i < userList.length; i++) {\n            distributeTo(userList[i]);\n        }\n    }\n\n    function allocateCapital(uint256 forInvestment, uint256 forProducts, uint256 forRedemptions) external onlyOwner {\n        uint256 total = forInvestment + forProducts + forRedemptions;\n        require(total <= stableToken.balanceOf(address(this)), \"Overallocated\");\n\n        investmentReserve = forInvestment;\n        productReserve = forProducts;\n        redemptionReserve = forRedemptions;\n\n        emit CapitalAllocated(forInvestment, forProducts, forRedemptions);\n    }\n\n    function spendCapital(address to, uint128 amount, string calldata purpose) external onlyOwner {\n        require(to != address(0), \"Invalid target\");\n        require(amount <= investmentReserve, \"Insufficient capital\");\n\n        investmentReserve -= amount;\n        stableToken.transfer(to, amount);\n\n        emit CapitalSpent(to, amount, purpose);\n    }\n\n    // --- Helpers ---\n\n    function getMultiplier(uint64 depositTime, uint32 committedQuarters) public view returns (uint256) {\n        uint256 depositQ = getQuarter(depositTime);\n        uint256 nowQ = getQuarter(block.timestamp);\n        uint256 held = nowQ > depositQ ? nowQ - depositQ : 0;\n\n        // Base multipliers based on committed quarters\n        uint256 baseMultiplier;\n        if (committedQuarters >= 6) {\n            baseMultiplier = 200;\n        } else if (committedQuarters >= 4) {\n            baseMultiplier = 150;\n        \n        } else {\n            baseMultiplier = 125;\n        }\n\n        // Apply full multiplier only if user actually held their deposit at least the committed duration\n        if (held >= committedQuarters) {\n            return baseMultiplier;\n        }\n\n        // Otherwise, scale proportionally to how long they actually held it (minimum 100%)\n        uint256 scaled = 100 + ((baseMultiplier - 100) * held) / committedQuarters;\n        return scaled > baseMultiplier ? baseMultiplier : scaled;\n    }\n\n\n    function computeEligibilityQuarter(uint64 timestamp, uint32 committedQuarters) public pure returns (uint256) {\n        uint32 quarter = getQuarter(timestamp);\n        uint32 startOfQ = getQuarterStart(timestamp);\n        uint32 daysIntoQuarter = (timestamp - startOfQ) / 1 days;\n\n        uint32 graceWindow = committedQuarters >= 3 ? 20 : 0;\n\n        return daysIntoQuarter <= graceWindow ? quarter : quarter + 1;\n    }\n\n\n    function getQuarter(uint256 ts) public pure returns (uint256) {\n        uint32 year = 1970 + (ts / 31556926);\n        uint32 month = (ts / 2592000) % 12 + 1;\n        uint32 quarter = (month - 1) / 3 + 1;\n        return year * 4 + quarter;\n    }\n\n    function getQuarterStart(uint256 ts) public pure returns (uint256) {\n        uint32 year = 1970 + (ts / 31556926);\n        uint32 month = (ts / 2592000) % 12 + 1;\n        uint32 quarterStartMonth = ((month - 1) / 3) * 3 + 1;\n        return toTimestamp(year, quarterStartMonth, 1);\n    }\n\n    function toTimestamp(uint32 year, uint32 month, uint32 day) internal pure returns (uint256) {\n        return (year - 1970) * 365 days + (month - 1) * 30 days + (day - 1) * 1 days;\n    }\n\n    function getUserVaultInfo(address user) external view returns (\n        uint128 amount,\n        uint32 committedQuarters,\n        uint32 unlockQuarter,\n        uint256[] memory redemptionIds,\n        Redemption[] memory redemptions\n    ) {\n        UserInfo memory u = users[user];\n        amount = u.amount;\n        committedQuarters = u.committedQuarters;\n        unlockQuarter = u.unlockQuarter;\n\n        // Get the list of redemption IDs associated with the user\n        redemptionIds = userRedemptionIds[user];\n\n        // Prepare array for redemptions\n        redemptions = new Redemption[](redemptionIds.length);\n        for (uint256 i = 0; i < redemptionIds.length; i++) {\n            redemptions[i] = redemptionQueue[redemptionIds[i]];\n        }\n\n        return (amount, committedQuarters, unlockQuarter, redemptionIds, redemptions);\n    }\n\n    function getUserDepositStatus(address user) external view returns (\n        uint256 depositAmount,\n        uint256 depositStartTime,\n        uint256 elapsedDays,\n        uint256 remainingDays,\n        bool isPending,\n        bool isClosed\n    ) {\n        UserInfo memory u = users[user];\n\n        depositAmount = u.amount;\n        depositStartTime = u.depositTime;\n\n        // If user has no deposit\n        if (depositAmount == 0) {\n            return (0, 0, 0, 0, false, true);\n        }\n\n        uint256 lockPeriodSeconds = u.committedQuarters * 90 days;\n        uint256 depositEndTime = u.depositTime + lockPeriodSeconds;\n\n        if (block.timestamp < depositEndTime) {\n            // Still within lock period\n            elapsedDays = (block.timestamp - u.depositTime) / 1 days;\n            remainingDays = (depositEndTime - block.timestamp) / 1 days;\n            isPending = true;\n            isClosed = false;\n        } else {\n            // Lock period completed\n            elapsedDays = u.committedQuarters * 90;\n            remainingDays = 0;\n            isPending = false;\n            isClosed = true;\n        }\n    }\n    \n}\n\n"
    },
    "contracts/stableSwapGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract StableSwapGateway is Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable GBD;\n    uint256 public feeBasisPoints = 125; // 1.25%\n    uint256 public constant MAX_BPS = 10000;\n\n    enum SwapStatus { Pending, Completed, Refunded }\n\n    struct SwapRecord {\n        address fromToken;\n        address toToken;\n        uint256 fromAmount;\n        uint256 toAmount;\n        uint256 fee;\n        SwapStatus status;\n        uint64 timestamp;\n    }\n\n    mapping(address => SwapRecord[]) private userSwaps;\n    mapping(address => bool) public stablecoinWhitelist;\n    mapping(address => bool) public redemptionLocked;\n    mapping(address => bool) public authorizedLockers;\n\n    event StableSwapped(address indexed user, address indexed stable, uint256 stableIn, uint256 gbdOut, uint256 fee);\n    event StableRefunded(address indexed user, address indexed stable, uint256 gbdIn, uint256 stableOut, uint256 fee);\n    event FeeUpdated(uint256 newFeeBps);\n    event StablecoinToggled(address stable, bool enabled);\n\n    constructor(address initialOwner, address _gbd, address[] memory initialStables) Ownable(initialOwner) {\n        require(_gbd != address(0), \"Invalid GBD address\");\n        GBD = IERC20(_gbd);\n\n        for (uint256 i = 0; i < initialStables.length; i++) {\n            address token = initialStables[i];\n            require(token != address(0), \"Zero address not allowed\");\n            stablecoinWhitelist[token] = true;\n            emit StablecoinToggled(token, true);\n        }\n    }\n\n    function toggleStablecoin(address stable, bool isEnabled) external onlyOwner {\n        require(stable != address(0), \"Invalid stablecoin address\");\n        stablecoinWhitelist[stable] = isEnabled;\n        emit StablecoinToggled(stable, isEnabled);\n    }\n\n    function setFee(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= 500, \"Fee too high\");\n        feeBasisPoints = newFeeBps;\n        emit FeeUpdated(newFeeBps);\n    }\n\n    function setAuthorizedLocker(address locker, bool status) external onlyOwner {\n        require(locker != address(0), \"Invalid locker\");\n        authorizedLockers[locker] = status;\n    }\n\n    // Swap stablecoin for GBD\n    function swapStableForGBD(address stable, uint128 amount) external {\n        require(stablecoinWhitelist[stable], \"Stablecoin not supported\");\n        require(amount > 0, \"Amount must be > 0\");\n\n        IERC20 stableToken = IERC20(stable);\n        stableToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        uint256 fee = (amount * feeBasisPoints) / MAX_BPS;\n        uint256 gbdOut = amount - fee;\n\n        require(GBD.balanceOf(address(this)) >= gbdOut, \"Insufficient GBD liquidity\");\n        GBD.safeTransfer(msg.sender, gbdOut);\n\n        emit StableSwapped(msg.sender, stable, amount, gbdOut, fee);\n\n        userSwaps[msg.sender].push(SwapRecord({\n            fromToken: stable,\n            toToken: address(GBD),\n            fromAmount: amount,\n            toAmount: gbdOut,\n            fee: fee,\n            status: SwapStatus.Completed,\n            timestamp: block.timestamp\n        }));\n    }\n\n    // Swap GBD for stablecoin\n    function swapGBDForStable(address stable, uint256 gbdAmount) external {\n        require(stablecoinWhitelist[stable], \"Stablecoin not supported\");\n        require(gbdAmount > 0, \"Amount must be > 0\");\n\n        uint256 fee = (gbdAmount * feeBasisPoints) / MAX_BPS;\n        uint256 stableOut = gbdAmount - fee;\n\n        IERC20 stableToken = IERC20(stable);\n        require(stableToken.balanceOf(address(this)) >= stableOut, \"Insufficient stablecoin liquidity\");\n\n        GBD.safeTransferFrom(msg.sender, address(this), gbdAmount);\n        stableToken.safeTransfer(msg.sender, stableOut);\n\n        emit StableRefunded(msg.sender, stable, gbdAmount, stableOut, fee);\n\n        userSwaps[msg.sender].push(SwapRecord({\n            fromToken: address(GBD),\n            toToken: stable,\n            fromAmount: gbdAmount,\n            toAmount: stableOut,\n            fee: fee,\n            status: SwapStatus.Completed,\n            timestamp: block.timestamp\n        }));\n    }\n\n    // Unlock redemption (by authorized lockers)\n    function unlockRedemption(address user) external {\n        require(authorizedLockers[msg.sender], \"Not authorized\");\n        require(user != address(0), \"Invalid user\");\n        redemptionLocked[user] = false;\n        // Optionally emit event\n    }\n\n    // Return GBD for stable (by owner)\n    function returnGBDForStable(address user, address stable, uint256 gbdAmount) external onlyOwner {\n        require(user != address(0), \"Invalid user\");\n        require(stablecoinWhitelist[stable], \"Stablecoin not supported\");\n        require(gbdAmount > 0, \"Zero GBD\");\n\n        uint256 fee = 0;\n        uint256 stableOut = gbdAmount - fee;\n\n        IERC20 stableToken = IERC20(stable);\n        require(stableToken.balanceOf(address(this)) >= stableOut, \"Not enough stablecoin liquidity\");\n\n        GBD.safeTransferFrom(user, address(this), gbdAmount);\n        stableToken.safeTransfer(user, stableOut);\n\n        emit StableRefunded(user, stable, gbdAmount, stableOut, fee);\n\n        userSwaps[msg.sender].push(SwapRecord({\n            fromToken: address(GBD),\n            toToken: stable,\n            fromAmount: gbdAmount,\n            toAmount: stableOut,\n            fee: fee,\n            status: SwapStatus.Completed,\n            timestamp: block.timestamp\n        }));\n    }\n\n    // Get user swaps\n    function getUserSwaps(address user) external view returns (SwapRecord[] memory) {\n        SwapRecord[] storage swaps = userSwaps[user];\n        SwapRecord[] memory swapsCopy = new SwapRecord[](swaps.length);\n        for (uint256 i = 0; i < swaps.length; i++) {\n            swapsCopy[i] = swaps[i];\n        }\n        return swapsCopy;\n    }\n\n    function getUserSwapsByStatus(address user, SwapStatus filterStatus) external view returns (SwapRecord[] memory) {\n        SwapRecord[] storage swaps = userSwaps[user];\n        uint256 count = 0;\n\n        // First pass: count how many swaps match the filter\n        for (uint256 i = 0; i < swaps.length; i++) {\n            if (swaps[i].status == filterStatus) {\n                count++;\n            }\n        }\n\n        // Create a new array with the size of matched swaps\n        SwapRecord[] memory filteredSwaps = new SwapRecord[](count);\n        uint256 index = 0;\n\n        // Second pass: populate the filtered array\n        for (uint256 i = 0; i < swaps.length; i++) {\n            if (swaps[i].status == filterStatus) {\n                filteredSwaps[index] = swaps[i];\n                index++;\n            }\n        }\n\n        return filteredSwaps;\n    }\n}"
    },
    "contracts/transferTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract TransferTracker {\n    enum Status { Pending, Completed, Failed }\n\n    struct Transfer {\n        address sender;\n        address recipient;\n        address token;\n        uint128 amount;\n        Status status;\n        bytes32 txhash;\n        uint64 timestamp;\n    }\n\n    // Store all transfers globally\n    Transfer[] public allTransfers;\n\n    // Mapping from user address to their transfer indices\n    mapping(address => uint256[]) private userTransferIndices;\n\n    event TransferRecorded(\n        address indexed user,\n        uint256 indexed transferId,\n        address indexed sender,\n        address recipient,\n        address token,\n        uint128 amount,\n        Status status,\n        bytes32 txhash,\n        uint64 timestamp\n    );\n\n    function recordTransfer(\n        address _recipient,\n        address _token,\n        uint256 _amount,\n        Status _status,\n        bytes32 _txhash\n    ) external {\n        Transfer memory newTransfer = Transfer({\n            sender: msg.sender,\n            recipient: _recipient,\n            token: _token,\n            amount: _amount,\n            status: _status,\n            txhash: _txhash,\n            timestamp: block.timestamp\n        });\n\n        allTransfers.push(newTransfer);\n        uint256 index = allTransfers.length - 1;\n        // Save index for involved users\n        userTransferIndices[msg.sender].push(index);\n        userTransferIndices[_recipient].push(index);\n\n        emit TransferRecorded(\n            msg.sender,\n            index,\n            msg.sender,\n            _recipient,\n            _token,\n            _amount,\n            _status,\n            _txhash,\n            block.timestamp\n        );\n    }\n\n    function getAllTransfersCount() external view returns (uint256) {\n        return allTransfers.length;\n    }\n\n    function getTransfer(uint256 index) external view returns (\n        address sender,\n        address recipient,\n        address token,\n        uint128 amount,\n        Status status,\n        bytes32 txhash,\n        uint64 timestamp\n    ) {\n        require(index < allTransfers.length, \"Index out of bounds\");\n        Transfer memory t = allTransfers[index];\n        return (t.sender, t.recipient, t.token, t.amount, t.status, t.txhash, t.timestamp);\n    }\n\n    function getTransfersInvolvingUser(address user) external view returns (Transfer[] memory) {\n        uint256 total = userTransferIndices[user].length;\n        Transfer[] memory involvedTransfers = new Transfer[](total);\n        for (uint256 i = 0; i < total; i++) {\n            involvedTransfers[i] = allTransfers[userTransferIndices[user][i]];\n        }\n        return involvedTransfers;\n    }\n}"
    },
    "contracts/uniswapV2Factory02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Pair {}\n\ncontract UniswapV2Factory {\n    address public feeTo;\n    address public feeToSetter;\n    mapping(address => mapping(address => address)) public getPair;\n    address[] public allPairs;\n\n    constructor(address _feeToSetter) {\n        feeToSetter = _feeToSetter;\n    }\n\n    function createPair(address tokenA, address tokenB) external returns (address pair) {\n        // Very minimal logic for pairing, replace with full UniswapV2Pair creation\n        require(tokenA != tokenB, \"Identical addresses\");\n        getPair[tokenA][tokenB] = address(0xDEAD); // placeholder\n        allPairs.push(address(0xDEAD));\n        return address(0xDEAD); // mock return\n    }\n\n    function setFeeTo(address _feeTo) external {\n        require(msg.sender == feeToSetter, \"Only feeToSetter\");\n        feeTo = _feeTo;\n    }\n}\n"
    },
    "contracts/uniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function approve(address, uint) external returns (bool);\n    function transferFrom(address, address, uint) external returns (bool);\n}\n\ninterface IUniswapV2Factory {\n    function getPair(address, address) external view returns (address);\n}\n\ncontract UniswapV2Router02 {\n    address public factory;\n    address public WGBD;\n\n    constructor(address _factory, address _WGBD) {\n        factory = _factory;\n        WGBD = _WGBD;\n    }\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint, // amountOutMin\n        address[] calldata path,\n        address to,\n        uint // deadline\n    ) external returns (uint[] memory amounts) {\n        IERC20(path[0]).transferFrom(msg.sender, to, amountIn);\n        uint[] memory out = new uint[](2);\n        out[0] = amountIn;\n        out[1] = amountIn; // mock: 1:1\n        return out;\n    }\n}\n"
    },
    "contracts/userQueryHub.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface ITransferTracker {\n    struct Transfer {\n        address sender;\n        address recipient;\n        address token;\n        uint128 amount;\n        uint8 status;\n        bytes32 txhash;\n        uint64 timestamp;\n    }\n\n    function getTransfersInvolvingUser(address user) external view returns (Transfer[] memory);\n}\n\ninterface IAssetPurchase {\n    struct Purchase {\n        address buyer;\n        uint64 assetId;\n        uint256 price;\n        uint64 timestamp;\n    }\n\n    function getUserPurchases(address user) external view returns (Purchase[] memory);\n}\n\ninterface ISmartVault {\n    struct Redemption {\n        uint256 id;\n        address user;\n        uint128 amount;\n        uint256 requestedAt;\n        bool fulfilled;\n    }\n\n    function getUserVaultInfo(address user) external view returns (\n        uint128 amount,\n        uint32 committedQuarters,\n        uint32 unlockQuarter,\n        uint256[] memory redemptionIds,\n        Redemption[] memory redemptions\n    );\n\n    function getUserDepositStatus(address user) external view returns (\n        uint256 depositAmount,\n        uint256 depositStartTime,\n        uint256 elapsedDays,\n        uint256 remainingDays,\n        bool isPending,\n        bool isClosed\n    );\n}\n\ninterface IStableSwapGateway {\n    enum SwapStatus { Pending, Completed, Refunded }\n\n    struct SwapRecord {\n        address fromToken;\n        address toToken;\n        uint256 fromAmount;\n        uint256 toAmount;\n        uint256 fee;\n        SwapStatus status;\n        uint64 timestamp;\n    }\n\n    function getUserSwaps(address user) external view returns (SwapRecord[] memory);\n    function getSwapsByStatus(address user, SwapStatus status) external view returns (SwapRecord[] memory);\n}\n\ncontract UserQueryHub {\n    ITransferTracker public transferTracker;\n    IAssetPurchase public assetPurchase;\n    ISmartVault public smartVault;\n    IStableSwapGateway public stableSwapGateway;\n\n    constructor(\n        address _transferTracker,\n        address _assetPurchase,\n        address _smartVault,\n        address _stableSwapGateway\n    ) {\n        transferTracker = ITransferTracker(_transferTracker);\n        assetPurchase = IAssetPurchase(_assetPurchase);\n        smartVault = ISmartVault(_smartVault);\n        stableSwapGateway = IStableSwapGateway(_stableSwapGateway);\n    }\n\n    function getUserActivity(address user) external view returns (\n        ITransferTracker.Transfer[] memory transfers,\n        IAssetPurchase.Purchase[] memory purchases,\n        ISmartVault.Redemption[] memory redemptions,\n        IStableSwapGateway.SwapRecord[] memory swaps\n    ) {\n        transfers = transferTracker.getTransfersInvolvingUser(user);\n        purchases = assetPurchase.getUserPurchases(user);\n\n        (, , , , redemptions) = smartVault.getUserVaultInfo(user);\n        swaps = stableSwapGateway.getUserSwaps(user);\n    }\n\n    function getUserVaultStatus(address user) external view returns (\n        uint256 depositAmount,\n        uint256 depositStartTime,\n        uint256 elapsedDays,\n        uint256 remainingDays,\n        bool isPending,\n        bool isClosed\n    ) {\n        return smartVault.getUserDepositStatus(user);\n    }\n}\n"
    },
    "contracts/WGBD.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract WGBD {\n    string public name = \"Wrapped GBD\";\n    string public symbol = \"WGBD\";\n    uint8  public decimals = 18;\n\n    event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    mapping(address => uint)                       public  balanceOf;\n    mapping(address => mapping(address => uint))  public  allowance;\n\n    receive() external payable {\n        deposit();\n    }\n\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint wad) public {\n        require(balanceOf[msg.sender] >= wad, \"insufficient balance\");\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        returns (bool)\n    {\n        require(balanceOf[src] >= wad, \"insufficient balance\");\n\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\n            require(allowance[src][msg.sender] >= wad, \"insufficient allowance\");\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n        return true;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}